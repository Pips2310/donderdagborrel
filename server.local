require('dotenv').config(); / Load environment variables from .env file

const express = require('express');
const cors = require('cors');
const sqlite3 = require('sqlite3').verbose();
const session = require('express-session');
const bcrypt = require('bcrypt'); / Import bcrypt
const nodemailer = require('nodemailer'); / Import nodemailer

const app = express();
const port = 3000;

/ Middleware
app.use(cors({
    / Alle origins toestaan voor ontwikkelingsdoeleinden (NIET voor productie!)
    origin: ['http://localhost:5500', 'http://192.168.178.150:5500'], / Nu inclusief je specifieke IP-adres
    credentials: true / Crucial for sending cookies (sessions)
}));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

/ Sessie-configuratie
app.use(session({
    secret: process.env.SESSION_SECRET || 'fallback_secret_for_dev_ONLY', / Use environment variable!
    resave: false,
    saveUninitialized: false,
    cookie: {
        secure: false, / Zet dit op 'false' voor lokale HTTP-verbindingen
        httpOnly: true, / Prevents client-side JS from accessing the cookie
        sameSite: 'lax',
        maxAge: 1000 * 60 * 60 * 24 / 24 hours
    }
}));

/ Database initialiseren
const db = new sqlite3.Database('./data.db', (err) => {
    if (err) {
        console.error('Error connecting to database:', err.message);
    } else {
        console.log('Connected to the SQLite database.');
    }
});

db.serialize(() => {
    / Aanwezigheid table with UNIQUE constraint
    db.run(`CREATE TABLE IF NOT EXISTS aanwezigheid (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        gebruikersnaam TEXT NOT NULL,
        datum TEXT NOT NULL,
        UNIQUE(gebruikersnaam, datum)
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS hosts (
        datum TEXT PRIMARY KEY,
        host TEXT NOT NULL
    )`);

    db.run(`CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        email TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        role TEXT DEFAULT 'user' NOT NULL,
        last_login TEXT DEFAULT NULL,
        reset_token TEXT DEFAULT NULL,
        reset_token_expires TEXT DEFAULT NULL
    )`);

    / Add last_login column if it doesn't exist
    db.all("PRAGMA table_info(users)", (err, columns) => {
        if (err) {
            console.error("Error checking users table info:", err);
            return;
        }
        const hasLastLogin = columns.some(col => col.name === 'last_login');
        if (!hasLastLogin) {
            db.run("ALTER TABLE users ADD COLUMN last_login TEXT DEFAULT NULL", (err) => {
                if (err) {
                    console.error("Error adding last_login column to users table:", err);
                } else {
                    console.log("Added 'last_login' column to 'users' table.");
                }
            });
        }
        / Add reset_token and reset_token_expires columns if they don't exist
        const hasResetToken = columns.some(col => col.name === 'reset_token');
        const hasResetTokenExpires = columns.some(col => col.name === 'reset_token_expires');

        if (!hasResetToken) {
            db.run("ALTER TABLE users ADD COLUMN reset_token TEXT DEFAULT NULL", (err) => {
                if (err) {
                    console.error("Error adding reset_token column to users table:", err);
                } else {
                    console.log("Added 'reset_token' column to 'users' table.");
                }
            });
        }
        if (!hasResetTokenExpires) {
            db.run("ALTER TABLE users ADD COLUMN reset_token_expires TEXT DEFAULT NULL", (err) => {
                if (err) {
                    console.error("Error adding reset_token_expires column to users table:", err);
                } else {
                    console.log("Added 'reset_token_expires' column to 'users' table.");
                }
            });
        }
    });

    / OPTIONEEL: Voeg een admin gebruiker toe als deze nog niet bestaat
    const adminUsername = process.env.ADMIN_USERNAME || 'admin';
    const adminPassword = process.env.ADMIN_PASSWORD || 'default_admin_password'; / Change in .env!
    const saltRounds = 10;

    db.get("SELECT * FROM users WHERE username = ?", [adminUsername], (err, row) => {
        if (err) {
            console.error("Error checking for admin user:", err);
            return;
        }
        if (!row) {
            bcrypt.hash(adminPassword, saltRounds, (err, hash) => {
                if (err) {
                    console.error("Error hashing admin password:", err);
                    return;
                }
                db.run("INSERT INTO users (username, email, password, role) VALUES (?, ?, ?, ?)",
                    [adminUsername, 'admin@example.com', hash, 'admin'],
                    (err) => {
                        if (err) {
                            console.error("Error inserting admin user:", err);
                        } else {
                            console.log(`Admin user '${adminUsername}' created successfully.`);
                        }
                    }
                );
            });
        } else {
            console.log(`Admin user '${adminUsername}' already exists.`);
        }
    });
});

/ Nodemailer transporter configuratie voor MailHog
const transporter = nodemailer.createTransport({
    host: "localhost",
    port: 1025, / MailHog's SMTP poort
    secure: false, / MailHog gebruikt geen TLS/SSL standaard
    ignoreTLS: true, / Negeer TLS-fouten
});

/ Functie om een willekeurige token te genereren
function generateToken() {
    return require('crypto').randomBytes(20).toString('hex');
}

/ --- Register endpoint ---
app.post('/api/register', (req, res) => {
    const { username, email, password } = req.body;

    if (!username || !email || !password) {
        return res.status(400).json({ message: 'Vul alle velden in.' });
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
        return res.status(400).json({ message: 'Ongeldig e-mailadres.' });
    }

    db.get(`SELECT * FROM users WHERE username = ? OR email = ?`, [username, email], (err, row) => {
        if (err) {
            console.error('Database error during user check:', err);
            return res.status(500).json({ message: 'Registratie mislukt door een interne serverfout.' });
        }
        if (row) {
            if (row.username === username) return res.status(409).json({ message: 'Deze gebruikersnaam is al in gebruik.' });
            if (row.email === email) return res.status(409).json({ message: 'Dit e-mailadres is al in gebruik.' });
        }

        const saltRounds = 10;
        bcrypt.hash(password, saltRounds, (err, hash) => {
            if (err) {
                console.error('Error hashing password during registration:', err);
                return res.status(500).json({ message: 'Fout bij verwerken wachtwoord.' });
            }

            db.run(`INSERT INTO users (username, email, password, role) VALUES (?, ?, ?, ?)`, [username, email, hash, 'user'], function(err) {
                if (err) {
                    console.error('Error inserting new user:', err);
                    return res.status(500).json({ message: 'Fout bij registratie.' });
                }
                res.status(201).json({ message: 'Account succesvol aangemaakt.', userId: this.lastID });
            });
        });
    });
});

/ --- Login endpoint ---
app.post('/api/login', (req, res) => {
    const { username, password } = req.body;

    if (!username || !password) {
        return res.status(400).json({ message: 'Gebruikersnaam en wachtwoord zijn verplicht.' });
    }

    db.get(`SELECT * FROM users WHERE username = ?`, [username], (err, user) => {
        if (err) {
            console.error('DB error during login (fetching user):', err);
            return res.status(500).json({ message: 'Inloggen mislukt door een interne serverfout.' });
        }
        if (!user) {
            return res.status(401).json({ message: 'Ongeldige gebruikersnaam of wachtwoord.' });
        }

        bcrypt.compare(password, user.password, (err, result) => {
            if (err) {
                console.error('Bcrypt error during password comparison:', err);
                return res.status(500).json({ message: 'Inloggen mislukt door een interne serverfout.' });
            }
            if (!result) { / Wachtwoord komt niet overeen
                return res.status(401).json({ message: 'Ongeldige gebruikersnaam of wachtwoord.' });
            }

            / Update last_login timestamp
            const now = new Date().toISOString();
            db.run(`UPDATE users SET last_login = ? WHERE id = ?`, [now, user.id], (updateErr) => {
                if (updateErr) {
                    console.error('Error updating last_login:', updateErr);
                }
            });

            / Inloggen succesvol: sessievariabelen instellen
            req.session.userId = user.id;
            req.session.username = user.username;
            req.session.role = user.role;

            console.log('âœ“ Inloggen succesvol, sessie:', req.session);

            res.json({
                message: 'Succesvol ingelogd!',
                gebruikersnaam: user.username,
                role: user.role
            });
        });
    });
});

/ --- Logout endpoint ---
app.post('/api/logout', (req, res) => { / Changed to POST for consistency, safer than GET
    req.session.destroy(err => {
        if (err) {
            console.error('Error destroying session:', err);
            return res.status(500).json({ message: 'Fout bij uitloggen.' });
        }
        res.clearCookie('connect.sid'); / Clear the session cookie from the client
        res.status(200).json({ message: 'Succesvol uitgelogd.' });
    });
});

/ Middleware for authorization
function isAdmin(req, res, next) {
    if (!req.session || !req.session.userId) {
        return res.status(401).json({ message: 'Niet geautoriseerd: U moet ingelogd zijn.' });
    }
    if (req.session.role === 'admin') {
        next(); / User is admin, proceed
    } else {
        return res.status(403).json({ message: 'Toegang geweigerd: Onvoldoende rechten.' });
    }
}

/ --- API endpoints ---

/ Aanwezigheid registreren (now allows admin to add for others)
app.post('/api/aanwezigheid', (req, res) => {
    if (!req.session || !req.session.username) {
        return res.status(401).json({ message: 'Niet geautoriseerd: U moet ingelogd zijn om aanwezigheid te registreren.' });
    }

    const { gebruikersnaam, datum } = req.body;

    if (!gebruikersnaam || !datum) {
        return res.status(400).json({ message: 'Gebruikersnaam en datum zijn verplicht.' });
    }

    / Allow admin to modify attendance for any user, otherwise restrict to self
    if (req.session.role !== 'admin' && gebruikersnaam !== req.session.username) {
        return res.status(403).json({ message: 'Niet toegestaan om aanwezigheid voor een andere gebruiker te wijzigen.' });
    }

    db.run(
        `INSERT INTO aanwezigheid (gebruikersnaam, datum) VALUES (?, ?)`,
        [gebruikersnaam, datum],
        function(err) {
            if (err) {
                console.error('Error inserting attendance:', err);
                if (err.errno === 19 && err.message.includes('UNIQUE constraint failed')) {
                    return res.status(409).json({ message: `${gebruikersnaam} is al aangemeld voor deze datum.` });
                }
                return res.status(500).json({ message: 'Fout bij opslaan aanwezigheid.' });
            }
            res.status(201).json({ message: 'Aanwezigheid opgeslagen.', id: this.lastID });
        }
    );
});

/ Aanwezigheid verwijderen (now allows admin to delete for others)
app.delete('/api/aanwezigheid', (req, res) => {
    if (!req.session || !req.session.username) {
        return res.status(401).json({ message: 'Niet geautoriseerd: U moet ingelogd zijn om aanwezigheid te verwijderen.' });
    }

    const { gebruikersnaam, datum } = req.body;

    if (!gebruikersnaam || !datum) {
        return res.status(400).json({ message: 'Gebruikersnaam en datum zijn verplicht.' });
    }

    / Allow admin to modify attendance for any user, otherwise restrict to self
    if (req.session.role !== 'admin' && gebruikersnaam !== req.session.username) {
        return res.status(403).json({ message: 'Niet toegestaan om aanwezigheid voor een andere gebruiker te wijzigen.' });
    }

    db.run(
        `DELETE FROM aanwezigheid WHERE gebruikersnaam = ? AND datum = ?`,
        [gebruikersnaam, datum],
        function(err) {
            if (err) {
                console.error('Error deleting attendance:', err);
                return res.status(500).json({ message: 'Fout bij verwijderen aanwezigheid.' });
            }
            if (this.changes === 0) {
                return res.status(404).json({ message: 'Aanwezigheid niet gevonden (misschien al afgemeld?).' });
            }
            res.status(200).json({ message: 'Aanwezigheid verwijderd.' });
        }
    );
});

/ Aanwezigen per datum ophalen
app.get('/api/aanwezigheid/datum/:datum', (req, res) => {
    const { datum } = req.params;
    db.all(
        `SELECT gebruikersnaam FROM aanwezigheid WHERE datum = ?`,
        [datum],
        (err, rows) => {
            if (err) {
                console.error('Error fetching attendance by date:', err);
                return res.status(500).json({ message: 'Fout bij ophalen aanwezigheden.' });
            }
            const namen = rows.map(r => r.gebruikersnaam);
            res.json(namen);
        }
    );
});

/ Alle datums ophalen waarop een gebruiker aanwezig was
app.get('/api/aanwezigheid/gebruiker/:gebruikersnaam', (req, res) => {
    if (!req.session || !req.session.username) {
        return res.status(401).json({ message: 'Niet geautoriseerd: U moet ingelogd zijn.' });
    }
    / Only allow user to fetch their own attendance, unless admin
    if (req.session.username !== req.params.gebruikersnaam && req.session.role !== 'admin') {
        return res.status(403).json({ message: 'Niet toegestaan om aanwezigheid van een andere gebruiker op te halen.' });
    }

    const { gebruikersnaam } = req.params;
    db.all(
        `SELECT datum FROM aanwezigheid WHERE gebruikersnaam = ? ORDER BY datum ASC`,
        [gebruikersnaam],
        (err, rows) => {
            if (err) {
                console.error('Error fetching user attendance dates:', err);
                return res.status(500).json({ message: 'Fout bij ophalen aanwezigheid gebruiker.' });
            }
            const datums = rows.map(r => r.datum);
            res.json(datums);
        }
    );
});

/ Host per datum ophalen
app.get('/api/host/:datum', (req, res) => {
    const { datum } = req.params;
    db.get(`SELECT host FROM hosts WHERE datum = ?`, [datum], (err, row) => {
        if (err) {
            console.error('Error fetching host:', err);
            return res.status(500).json({ message: 'Fout bij ophalen host.' });
        }
        res.json({ host: row ? row.host : null });
    });
});

/ NEW: Endpoint to get all dates a specific user has hosted
app.get('/api/hosts/gebruiker/:gebruikersnaam', (req, res) => {
    if (!req.session || !req.session.username) {
        return res.status(401).json({ message: 'Niet geautoriseerd: U moet ingelogd zijn.' });
    }
    / Only allow user to fetch their own hosting data, unless admin
    if (req.session.username !== req.params.gebruikersnaam && req.session.role !== 'admin') {
        return res.status(403).json({ message: 'Niet toegestaan om hostingdata van een andere gebruiker op te halen.' });
    }

    const { gebruikersnaam } = req.params;
    db.all(
        `SELECT datum FROM hosts WHERE host = ? ORDER BY datum ASC`,
        [gebruikersnaam],
        (err, rows) => {
            if (err) {
                console.error('Error fetching user host dates:', err);
                return res.status(500).json({ message: 'Fout bij ophalen hostingdata gebruiker.' });
            }
            const datums = rows.map(r => r.datum);
            res.json(datums);
        }
    );
});


/ Host opslaan/updaten (ALLEEN ADMIN)
app.post('/api/host/:datum', isAdmin, (req, res) => {
    const { datum } = req.params;
    const { host } = req.body;

    if (typeof host !== 'string' || host.trim() === '') {
        return res.status(400).json({ message: 'Host naam mag niet leeg zijn.' });
    }

    const trimmedHost = host.trim();
    console.log(`Admin '${req.session.username}' wijzigt host voor datum ${datum} naar '${trimmedHost}'`);

    db.run(
        `INSERT INTO hosts (datum, host)
         VALUES (?, ?)
         ON CONFLICT(datum) DO UPDATE SET host=excluded.host`,
        [datum, trimmedHost],
        function(err) {
            if (err) {
                console.error('Error saving host to hosts table:', err);
                return res.status(500).json({ message: 'Fout bij opslaan host.' });
            }

            / Ensure the new host is also marked as present for that date
            db.run(
                `INSERT INTO aanwezigheid (gebruikersnaam, datum) VALUES (?, ?)
                 ON CONFLICT(gebruikersnaam, datum) DO NOTHING`,
                [trimmedHost, datum],
                (err) => {
                    if (err) {
                        console.error('Error adding host to attendance table:', err);
                    }
                    res.status(200).json({ message: 'Host succesvol opgeslagen en aanwezigheid bijgewerkt.' });
                }
            );
        }
    );
});

/ Get all registered users (ADMIN ONLY) - Existing endpoint, but we need a public one for stats
app.get('/api/users', isAdmin, (req, res) => {
    db.all(`SELECT username, email, last_login, role FROM users`, (err, rows) => {
        if (err) {
            console.error('Error fetching all users:', err);
            return res.status(500).json({ message: 'Fout bij ophalen gebruikerslijst.' });
        }
        res.json(rows);
    });
});

/ Endpoint to get a list of all unique users (for statistics)
app.get('/api/users/list', (req, res) => {
    / Combine usernames from 'users', 'aanwezigheid', and 'hosts' tables
    const sql = `
        SELECT username AS user FROM users
        UNION
        SELECT gebruikersnaam AS user FROM aanwezigheid
        UNION
        SELECT host AS user FROM hosts
        ORDER BY user ASC
    `;
    db.all(sql, (err, rows) => {
        if (err) {
            console.error('Error fetching list of unique users for statistics:', err);
            return res.status(500).json({ message: 'Fout bij ophalen gebruikerslijst voor statistieken.' });
        }
        const usernames = rows.map(row => row.user); / Map 'user' alias
        console.log('Backend: All unique users for statistics:', usernames); / Debug log
        res.json(usernames);
    });
});


/ Endpoint to get attendance summary for all users (for statistics)
app.get('/api/attendance/summary', (req, res) => {
    const startOfYear = new Date(Date.UTC(new Date().getUTCFullYear(), 0, 1)).toISOString().split('T')[0];
    const today = new Date().toISOString().split('T')[0];

    console.log(`Backend: Fetching attendance summary for dates between ${startOfYear} and ${today}`); / Added log
    const sql = `SELECT gebruikersnaam AS user, COUNT(*) AS count
                 FROM aanwezigheid
                 WHERE datum >= ? AND datum <= ?
                 GROUP BY gebruikersnaam
                 ORDER BY count DESC`;
    db.all(
        sql,
        [startOfYear, today],
        (err, rows) => {
            if (err) {
                console.error('Error fetching attendance summary:', err);
                return res.status(500).json({ message: 'Fout bij ophalen aanwezigheidsstatistieken.' });
            }
            console.log('Backend: Attendance summary rows:', rows); / Added log
            res.json(rows);
        }
    );
});

/ Endpoint to get host summary for all users (for statistics)
app.get('/api/hosts/summary', (req, res) => {
    const startOfYear = new Date(Date.UTC(new Date().getUTCFullYear(), 0, 1)).toISOString().split('T')[0];
    const today = new Date().toISOString().split('T')[0];

    console.log(`Backend: Fetching hosts summary for dates between ${startOfYear} and ${today}`); / Added log
    const sql = `SELECT host AS user, COUNT(*) AS count
                 FROM hosts
                 WHERE datum >= ? AND datum <= ?
                 GROUP BY host
                 ORDER BY count DESC`;
    db.all(
        sql,
        [startOfYear, today],
        (err, rows) => {
            if (err) {
                console.error('Error fetching hosts summary:', err);
                return res.status(500).json({ message: 'Fout bij ophalen hostingstatistieken.' });
            }
            console.log('Backend: Hosts summary rows:', rows); / Added log
            res.json(rows);
        }
    );
});

/ NEW: Wachtwoord vergeten aanvraag
app.post('/api/forgot-password', (req, res) => {
    const { email } = req.body;

    if (!email) {
        return res.status(400).json({ message: 'E-mailadres is verplicht.' });
    }

    db.get(`SELECT * FROM users WHERE email = ?`, [email], (err, user) => {
        if (err) {
            console.error('Database error during forgot-password:', err);
            return res.status(500).json({ message: 'Er is een interne serverfout opgetreden.' });
        }
        if (!user) {
            / Stuur altijd een succesbericht, zelfs als de e-mail niet bestaat, om user enumeration te voorkomen
            return res.status(200).json({ message: 'Als het e-mailadres bekend is, is er een link voor het opnieuw instellen van het wachtwoord verzonden.' });
        }

        const token = generateToken();
        const expires = Date.now() + 3600000; / Token is 1 uur geldig

        db.run(`UPDATE users SET reset_token = ?, reset_token_expires = ? WHERE id = ?`, [token, expires, user.id], (updateErr) => {
            if (updateErr) {
                console.error('Error updating reset token:', updateErr);
                return res.status(500).json({ message: 'Fout bij het genereren van de resetlink.' });
            }

            const resetLink = `/reset-password.html?token=${token}`; / Pas dit aan naar je frontend URL
            const mailOptions = {
                from: 'no-reply@donderdagen2025.com',
                to: user.email,
                subject: 'Wachtwoord opnieuw instellen voor Donderdagen 2025',
                html: `
                    <p>Beste ${user.username},</p>
                    <p>U heeft een verzoek ingediend om uw wachtwoord opnieuw in te stellen voor uw account op Donderdagen 2025.</p>
                    <p>Klik op de volgende link om uw wachtwoord opnieuw in te stellen:</p>
                    <p><a href="${resetLink}">Wachtwoord opnieuw instellen</a></p>
                    <p>Deze link is 1 uur geldig. Als u dit niet heeft aangevraagd, kunt u deze e-mail negeren.</p>
                    <p>Met vriendelijke groet,</p>
                    <p>Het Donderdagen 2025 Team</p>
                `,
            };

            transporter.sendMail(mailOptions, (error, info) => {
                if (error) {
                    console.error('Error sending email:', error);
                    return res.status(500).json({ message: 'Fout bij het verzenden van de e-mail.' });
                }
                console.log('Email sent: %s', info.messageId);
                res.status(200).json({ message: 'Als het e-mailadres bekend is, is er een link voor het opnieuw instellen van het wachtwoord verzonden.' });
            });
        });
    });
});

/ NEW: Wachtwoord opnieuw instellen endpoint
app.post('/api/reset-password', async (req, res) => {
    const { token, newPassword } = req.body;

    if (!token || !newPassword) {
        return res.status(400).json({ message: 'Token en nieuw wachtwoord zijn verplicht.' });
    }

    db.get(`SELECT * FROM users WHERE reset_token = ? AND reset_token_expires > ?`, [token, Date.now()], async (err, user) => {
        if (err) {
            console.error('Database error during reset-password (fetching user):', err);
            return res.status(500).json({ message: 'Er is een interne serverfout opgetreden.' });
        }
        if (!user) {
            return res.status(400).json({ message: 'Ongeldige of verlopen resetlink.' });
        }

        try {
            const hashedPassword = await bcrypt.hash(newPassword, 10);
            db.run(`UPDATE users SET password = ?, reset_token = NULL, reset_token_expires = NULL WHERE id = ?`, [hashedPassword, user.id], (updateErr) => {
                if (updateErr) {
                    console.error('Error updating password:', updateErr);
                    return res.status(500).json({ message: 'Fout bij het bijwerken van het wachtwoord.' });
                }
                res.status(200).json({ message: 'Wachtwoord succesvol opnieuw ingesteld.' });
            });
        } catch (hashError) {
            console.error('Error hashing new password:', hashError);
            res.status(500).json({ message: 'Fout bij het verwerken van het nieuwe wachtwoord.' });
        }
    });
});


app.listen(port, () => {
    console.log(`Backend draait op http://localhost:${port}`);
    console.log(`Zorg ervoor dat uw frontend draait op http://localhost:5500 of pas de CORS origin aan.`);
    if (!process.env.SESSION_SECRET) {
        console.warn('\n--- WAARSCHUWING: SESSION_SECRET is niet ingesteld in .env! Gebruikt fallback secret. ---');
        console.warn('--- Genereer een sterke, willekeurige string en voeg deze toe aan uw .env bestand. ---\n');
    }
    if (!process.env.ADMIN_PASSWORD || process.env.ADMIN_PASSWORD === 'default_admin_password') {
        console.warn('\n--- WAARSCHUWING: ADMIN_PASSWORD is niet sterk of is standaard ingesteld in .env! ---');
        console.warn('--- Verander dit direct in een sterk wachtwoord in uw .env bestand. ---\n');
    }
});
